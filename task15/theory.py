# Всегда следи:
# 1. За допустимыми значениями
#   натуральное A - range(1, 1000)
#   неотрицательное A - range(0, 1000)
#   целое A - range(-1000, 1000)
# 2. Что нужно дать в ответ
#   Наибольшее значение - range(1, 1000)[::-1] -> break
#   Наименьшее значение - range(1, 1000) -> break

# & - побитовая/поразрядная конъюнкция
# | - побитовая/поразрядная дизъюнкция

# Поиск отрезка A

from itertools import combinations


def f(x):
    P = 12 <= x <= 26
    Q = 30 <= x <= 53
    A = A1 <= x <= A2
    return (A <= P) or Q


line_A = [12, 26, 30, 53]  # Числа обязательно в порядке возрастания
line_x = [12.5, 26.5, 30.5]  # Берем числа между парами из line_A

ans = []
# combinations(line_A, 2) - извлекает пары из line_A, т.е. формирует все возможные отрезки
for A1, A2 in combinations(line_A, 2):
    if all(f(x) for x in line_x):  # проверка для тождественно истинного выражения
        ans.append(A2 - A1)
    if all(not f(x) for x in line_x):  # проверка для тождественно ложного выражения
        ans.append(A2 - A1)
print(max(ans))


# Поиск параметра / значения A

def DEL(n, m):
    return n % m == 0


def f(x):
    return (DEL(x, 2) <= (x % 3 != 0)) or (x + A >= 80)


for A in range(1, 1000):
    if all(f(x) for x in range(1, 1000)):
        print(A)
        break

# Ручные решения

# Алгоритм на отрезки
# 1. Упрощаем выражение, пока в нём не останутся только not, and, or
# 2. На числовую прямую выносим значения существующих отрезков
# 3. Закрашиваем области, где уже получаем истину из нашего высказывания
# 4.1. Подбираем отрезок под A таким образом, чтобы он перекрыл всю незакрашенную область
# 4.2. Подбираем отрезок под not A таким образом, чтобы он поместился внутри уже закрашенной области